{"root":{"data":{"id":"bl8pv4yt3604","created":1525503517008,"text":"python"},"children":[{"data":{"id":"bl8pwcwhbp4w","created":1525503612645,"text":"内置模块","note":"## datetime\n注意到datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。\n\n如果仅导入import datetime，则必须引用全名datetime.datetime。\n```\nfrom datetime import datetime\nnow = datetime.now() # 获取当前datetime\nprint(now)\nprint(type(now))\ndt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime\nprint(dt)\ndt.timestamp() # 时间戳\nt = 1429417200.0\nprint(datetime.fromtimestamp(t)) # 时间戳转时间\ncday = datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S') # 字符串转时间\nprint(cday)\nnow = datetime.now()\nprint(now.strftime('%a, %b %d %H:%M')) # 时间转字符串\n```\n\n## collections\n处理集合类\n\n\n"},"children":[]},{"data":{"id":"bl8pwcwgxe88","created":1525503612645,"text":"函数","note":"## 默认参数\n```\ndef power(x, n=2):\n    s = 1\n    while n > 0:\n        n = n - 1\n        s = s * x\n    return s\n```\n\n\n### 多次调用默认参数\n定义默认参数要牢记一点：默认参数必须指向不变对象\n\n否则多次调用会被改变\n```\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n```\n\n## 可变参数，\n参数个数可变\n定义参数元组前面带*，调用将元组元素传入，可变参数在函数调用时自动组装为一个tuple。\n```\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n```\n调用\n```\ncalc(1, 2)\ncalc()\n```\n## 关键字参数\n可传可不传，可以传任意个，自动组装为字典\n```\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n```\n```\n>>> person('Adam', 45, gender='M', job='Engineer')\nname: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}\n```\n## 命名关键字参数\n只接收city和job作为关键字参数。这种方式定义的函数如下：\n```\ndef person(name, age, *, city, job):\n    print(name, age, city, job)\nperson('Jack', 24, city='Beijing', job='Engineer')\n```\n### 与可变参数混搭\n如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：\n```\ndef person(name, age, *args, city, job):\n    print(name, age, args, city, job)\n```\n### 缺省值\n命名关键字参数可以有缺省值，从而简化调用：\n```\ndef person(name, age, *, city='Beijing', job):\n    print(name, age, city, job)\n```\n## 参数组合顺序\n参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n\n## 装饰器\ndecorator，所以接受一个函数作为参数，并返回一个函数。\n\n以下写法等价：\n```\ndef log(func):\n    def wrapper(*args, **kw):\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\ndef now():\n    print('2015-3-25')\nnow = log(now)\nnow()\n```\n\n```\ndef log(func):\n    def wrapper(*args, **kw):\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n@log\ndef now():\n    print('2015-3-25')\nnow()\n# @log放到now()函数的定义处，相当于执行了语句：now = log(now)\n```\n\n### 装饰器带参数\n@'code'，'code'是函数就行，最后用来传入将要装饰的函数\n```\ndef log(text):\n    def decorator(func):\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n@log('execute')\ndef now():\n    print('2015-3-25')\nnow()\n```\n\n### 完整的装饰器函数写法\n@functools.wraps(func),防止函数的__name__属性被wrapper覆盖\n```\nimport functools\n\ndef log(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kw):\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n```\n\n## 偏函数\nfunctools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。\n\n如下int2用来转换为2进制数据\n```\nimport functools\nint2 = functools.partial(int, base=2)\nint2('1000000')\n```"},"children":[]},{"data":{"id":"bl8pwcwgunco","created":1525503612645,"text":"基本语法","note":"## 基础语法\n### 输入输出\n```\nname = input()\nprint('hello,', name)\nhh = input()\n```\n### 数据类型\n+ 整数\n可以处理任意大小的整数\n十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。\n+ 浮点数\n把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。\n+ 字符串\n以单引号'或双引号\"括起来的任意文本，\n  + 转义\n  ```\n  'I\\'m \\\"OK\\\"!'\n  ```\n  + 不转义\n   r''表示''内部的字符串默认不转义\n  ```\n  >>> print(r'\\\\\\t\\\\')\n  \\\\\\t\\\\\n  ```\n  + 多行\n  ```\n  print('''line1\n  line2\n  line3''')\n  ```\n+ 布尔值\n布尔值可以用and、or和not运算。\n```\n>>> True and True\nTrue\n>>> True and False\nFalse\n>>> False and False\nFalse\n>>> 5 > 3 and 3 > 1\nTrue\n```\n+ 空值\n空值是Python里一个特殊的值，用None表示\n\n### 变量\n变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如\n```\nt_007 = 'T007'\n```\n在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：\n```\na = 123 # a是整数\nprint(a)\na = 'ABC' # a变为字符串\nprint(a)\n```\n\n+ 常量\n\n所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：\n```\nPI = 3.14159265359\n```\n+ 两种除法\n正常除法得到的永远是浮点数\n还有一种除法是//，称为地板除，两个整数的除法仍然是整数：\n```\n>>> 10 / 3\n3.3333333333333335\n>>> 10 // 3\n3\n```\n\n+ 注意\n Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。\nPython的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。\n\n\n## list与元组\n\n1. list与js数组类似\n### list特性\n1. 倒着访问,-1倒数第一个\n```\nclassmates = ['Michael', 'Bob', 'Tracy']\nprint(classmates[-1],classmates[-2],classmates[-3])\n```\n2. 增加\n```\nclassmates.append('Adam')\n```\n3. 删除,pop()删除最后一个，pop(index)删除指定位置\n```\nclassmates.pop()\n```\n4. 插入指定位置，insert(index,value)\n```\nclassmates.pop(1,'hh')\n```\n5. 获取长度\n```\nlen(classmates)\n```\n\n### 元组\n类似数组，但是元素不可改变\n\n陷阱，如果元素是list则其元素可以改变\n#### 定义\n```\nclassmates = ('Michael', 'Bob', 'Tracy')\n```\n##### 只有一个元素时\n\n只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：\n```\n>>> t = (1,)\n>>> t\n(1,)\n```\n\n## 字典\ndict，看起来像js对象\n\n访问形式不同，需中括号，一般key为字符串\n```\nc = 'Bob'\nd = {'Michael': 95, 'Bob': 75, 'Tracy': 85}\nprint(d[c])\n```\n### 获取某个key\n#### 判断是否存在\n```\n>>> 'Thomas' in d\nFalse\n```\n不存在返回None,或者自己指定返回某个值\n```\n>>> d.get('Thomas')\n>>> d.get('Thomas', -1)\n```\n### 删除key\n```\nd.pop('Bob')\n```\n\n## set集合\n类似于字典，不存储value\n### 定义\n需要提供一个list作为输入集合\n\n显示的顺序也不表示set是有序的\n```\n>>> s = set([1, 2, 3])\n>>> s\n{1, 2, 3}\n```\n\n### 添加删除\nadd(key) remove(key)\n\n\n##  集合操作\nset可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作\n```\n>>> s1 = set([1, 2, 3])\n>>> s2 = set([2, 3, 4])\n>>> s1 & s2\n{2, 3}\n>>> s1 | s2\n{1, 2, 3, 4}\n```\n\n## 条件语句\n\n```\nage = 3\nif age >= 18:\n    print('adult')\nelif age >= 6:\n    print('teenager')\nelse:\n    print('kid')\n```\n\n## 循环\nbreak跳出循环，continue跳出当前循环\n### for in\n```\nsum = 0\nfor x in range(101):\n    sum = sum + x\nprint(sum)\n```\n\n### 获取索引\nenumerate\n```\nfor i, value in enumerate(['A', 'B', 'C']):\n     print(i, value)\n```\n\n### while \n```\nn = 0\nwhile n < 10:\n    n = n + 1\n    if n % 2 == 0: # 如果n是偶数，执行continue语句\n        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行\n    print(n)\n```\n"},"children":[]},{"data":{"id":"bl8pwcwhu348","created":1525503612646,"text":"多进程与多线程","note":"## 基础\n1. 线程是操作系统直接支持的执行单元\n2. 进程是由若干线程组成的，一个进程至少有一个线程\n3. 任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程\n\n\n\n## windows下多进程\n\n1. 引入multiprocessing模块\n2. Process类，实例化一个进程，参数为函数名、该函数的实参\n3. p.start启动，p.join()等待结束，p.terminate()强制结束\n\n```\nfrom multiprocessing import Process\nimport os\n\n# 子进程要执行的代码\ndef run_proc(name):\n    print('Run child process %s (%s)...' % (name, os.getpid()))\n\nif __name__=='__main__':\n    print('Parent process %s.' % os.getpid())\n    p = Process(target=run_proc, args=('test',))\n    print('Child process will start.')\n    p.start()\n    p.join()\n    print('Child process end.')\n```\n### 子进程\n#### 进程池\n对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。\n```\nfrom multiprocessing import Pool\nimport os, time, random\n\ndef long_time_task(name):\n    print('Run task %s (%s)...' % (name, os.getpid()))\n    start = time.time()\n    time.sleep(random.random() * 3)\n    end = time.time()\n    print('Task %s runs %0.2f seconds.' % (name, (end - start)))\n\nif __name__=='__main__':\n    print('Parent process %s.' % os.getpid())\n    p = Pool(4)\n    for i in range(5):\n        p.apply_async(long_time_task, args=(i,))\n    print('Waiting for all subprocesses done...')\n    p.close()\n    p.join()\n    print('All subprocesses done.')\n```\n#### 输入输出\n引用subprocess模块\n\n\n### 进程间通信\n1. 引入Queue模块\n2. 不同的进程以同一个Queue实例为中介通信\n```\nfrom multiprocessing import Process, Queue\nimport os, time, random\n\n# 写数据进程执行的代码:\ndef write(q):\n    print('Process to write: %s' % os.getpid())\n    for value in ['A', 'B', 'C']:\n        print('Put %s to queue...' % value)\n        q.put(value)\n        time.sleep(random.random())\n\n# 读数据进程执行的代码:\ndef read(q):\n    print('Process to read: %s' % os.getpid())\n    while True:\n        value = q.get(True)\n        print('Get %s from queue.' % value)\n\nif __name__=='__main__':\n    # 父进程创建Queue，并传给各个子进程：\n    q = Queue()\n    pw = Process(target=write, args=(q,))\n    pr = Process(target=read, args=(q,))\n    # 启动子进程pw，写入:\n    pw.start()\n    # 启动子进程pr，读取:\n    pr.start()\n    # 等待pw结束:\n    pw.join()\n    # pr进程里是死循环，无法等待其结束，只能强行终止:\n    pr.terminate()\n```\n\n## 多线程\nthreading模块\n### 多线程创建\ncurrent_thread返回当前线程的实例\n\n调用start()开始执行\n\njoin()等待结束\n\n```\nimport time, threading\n\n# 新线程执行的代码:\ndef loop():\n    print('thread %s is running...' % threading.current_thread().name)\n    n = 0\n    while n < 5:\n        n = n + 1\n        print('thread %s >>> %s' % (threading.current_thread().name, n))\n        time.sleep(1)\n    print('thread %s ended.' % threading.current_thread().name)\n\nprint('thread %s is running...' % threading.current_thread().name)\nt = threading.Thread(target=loop, name='LoopThread')\nt.start()\nt.join()\nprint('thread %s ended.' % threading.current_thread().name)\n```\n\n### 多线程的锁\n防止对同一变量同时操作出错，多进程不需要\n```\nbalance = 0\nlock = threading.Lock()\n\ndef run_thread(n):\n    for i in range(100000):\n        # 先要获取锁:\n        lock.acquire()\n        try:\n            # 放心地改吧:\n            change_it(n)\n        finally:\n            # 改完了一定要释放锁:\n            lock.release()\n```\n\n####  ThreadLocal\n也可以解决同一变量的问题\n```\nimport threading\n\n# 创建全局ThreadLocal对象:\nlocal_school = threading.local()\n\ndef process_student():\n    # 获取当前线程关联的student:\n    std = local_school.student\n    print('Hello, %s (in %s)' % (std, threading.current_thread().name))\n\ndef process_thread(name):\n    # 绑定ThreadLocal的student:\n    local_school.student = name\n    process_student()\n\nt1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')\nt2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')\nt1.start()\nt2.start()\nt1.join()\nt2.join()\n```\n### 并发\n\nPython解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。\n\nPython虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。\n\n\n\n## 进程 vs. 线程\n多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程\n\n缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。\n\n多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。\n\n## 计算密集型 vs. IO密集型\n\n计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。\n\nIO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。\n\n\n##  分布式进程\n在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。\n\nPython的multiprocessing模块不但支持多进程，其中managers子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于managers模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。"},"children":[]},{"data":{"id":"bl8pwcwhfk00","created":1525503612646,"text":"小技巧","note":"## 任意参数的函数\nwrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用\n```\n def wrapper(*args, **kw):\n    pass\n```\n\n## 直接在Unix/Linux/Mac上运行\n```\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n```\n\n## 首行注释\n\n任何模块代码的第一个字符串都被视为模块的文档注释；\n\n## 作者\n\n__author__ = 'Michael Liao'\n\n\n## 运行测试\n当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。\n```\nif __name__=='__main__':\n    test()\n```\n\n## 私有变量和函数\n\n+ 类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等；\n\n## 对象自定义len方法\n\n```\nclass MyDog(object):\n    def __len__(self):\n        return 100\ndog = MyDog()\nprint(len(dog))\n```\n\n### 判断不是整数\n```\n not isinstance(value, int):\n```\n### 是否切片\nisinstance(n, slice)\n\n\n### 斐波那契数列 切片\n```\nclass Fib(object):\n    def __init__(self):\n        self.a, self.b = 0, 1 # 初始化两个计数器a，b\n\n    def __iter__(self):\n        return self # 实例本身就是迭代对象，故返回自己\n\n    def __next__(self):\n        self.a, self.b = self.b, self.a + self.b # 计算下一个值\n        if self.a > 100000: # 退出循环的条件\n            raise StopIteration()\n        return self.a # 返回下一个值\n    def __getitem__(self, n):\n        if isinstance(n, int): # n是索引\n            a, b = 1, 1\n            for x in range(n):\n                a, b = b, a + b\n            return a\n        if isinstance(n, slice): # n是切片\n            start = n.start\n            stop = n.stop\n            if start is None:\n                start = 0\n            a, b = 1, 1\n            L = []\n            for x in range(stop):\n                if x >= start:\n                    L.append(a)\n                a, b = b, a + b\n            return L\nf = Fib()\nprint(f[0:9])\n```"},"children":[]},{"data":{"id":"bl8pwcwhpn48","created":1525503612646,"text":"小知识","note":"### 变量定义\n### 简写\n1. n, a, b = 0, 0, 1\n### 赋值简写\na, b = b, a + b\n\n等价于\n```\nt = (b, a + b) # t是一个tuple\na = t[0]\nb = t[1]\n```\n\n### int\ns = input('birth: ')\nbirth = int(s)\n\n#### 进制转换\nint('12345', 16)\n\n### range \n如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：\n\n```\n>>> list(range(5))\n[0, 1, 2, 3, 4]\n```\nrange生成序列，可以做循环使用\n\n```\nsum = 0\nfor x in range(101):\n    sum = sum + x\nprint(sum)\n```\n\n### list排序 sort\n```\na = ['c', 'b', 'a']\na.sort()\nprint(a)\n```\n### 字符串替换\n```\n>>> a = 'abc'\n>>> a.replace('a', 'A')\n'Abc'\n>>> a\n'abc'\n```\n\n## 字符串小写\n\n```\ns.lower()\n```\n\n## 判断是否字符串\n```\nx = 23;\nisinstance(x, str)\n```\n\n## pass\npass 不做任何事情，一般用做占位语句。\n\n## isinstance\n判断一个变量是否是某个类型可以用isinstance()判断：\n\n##  判断与获取属性\nhasattr(obj, 'read')\ngetattr(obj, 'z') # 获取属性'z'\ngetattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404\ndir('ABC') # 获取一个对象的所有属性和方法\n\n##类型判断\n\nisinstance types\n\n注意最下方isinstance的用法，可以将指定类型及其子类“一网打尽”。\n\n```\n>>> import types\n>>> def fn():\n...     pass\n...\n>>> type(fn)==types.FunctionType\nTrue\n>>> type(abs)==types.BuiltinFunctionType\nTrue\n>>> type(lambda x: x)==types.LambdaType\nTrue\n>>> type((x for x in range(10)))==types.GeneratorType\nTrue\n\nisinstance([1, 2, 3], (list, tuple))\n```\n\n## 特殊属性（方法）\n\n__str__ 定义用来打印的字符串（给用户）\n__repr__ 定义用来打印的字符串（给开发者）\n\n## 报错\n### KeyError\n不存在某属性\n```\nexcept KeyError:\n    raise AttributeError(r\"'Model' object has no attribute '%s'\" % key)\n```\n## 全局变量\n使用global声明\ndef change_it(n):\n    global balance\n    balance = balance + n\n    balance = balance - n\n\n## 正则\n\nr为前缀则不需要考虑转义\n```\ns = r'ABC\\-001' # Python的字符串\n# 对应的正则表达式字符串不变：\n# 'ABC\\-001'\n```\n### re模块\nmatch()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None\n```\nimport re\nre.match(r'^\\d{3}\\-\\d{3,8}$', '010-12345')\n```\n### 切分字符串\n```\nre.split(r'\\s+', 'a b   c')\n['a', 'b', 'c']\n```\n"},"children":[]},{"data":{"id":"bl8pwcwhk9kc","created":1525503612646,"text":"常用模块及语法","note":"## time\n### 当前时间\ntime.time()\n### 睡眠\ntime.sleep(1)"},"children":[]},{"data":{"id":"bl8pwcwhl7kg","created":1525503612646,"text":"开发环境","note":"## pycharm激活\n\nlicense server :http://xidea.online\n\n## python 2 3版本切换\n\n1. 首先需要安装好不同的py版本\n2. 安装好pycharm\n3. file、settings、project、project interpreter选择版本即可\n\n## pip源\n\n例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider，这样就会从清华这边的镜像去安装pyspider库。\n\n```\n新版ubuntu要求使用https源，要注意。\n\n清华：https://pypi.tuna.tsinghua.edu.cn/simple\n\n阿里云：http://mirrors.aliyun.com/pypi/simple/\n\n中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/\n\n华中理工大学：http://pypi.hustunique.com/\n\n山东理工大学：http://pypi.sdutlinux.org/ \n\n豆瓣：http://pypi.douban.com/simple/\n```\n\n#### 永久修改，一劳永逸：\n\nLinux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)\n\n内容如下：\n```\n[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n[install]\ntrusted-host=mirrors.aliyun.com\n```\nwindows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini。内容同上。\n\n\n\n"},"children":[]},{"data":{"id":"bl8pwcwhunco","created":1525503612646,"text":"简单程序","note":"## md5+salt加密\n```\n# -------------------------------------------  \n# Python简单密码加密程序  \n# 随机生成4位salt，与原始密码组合，通过md5加密  \n# Author : Lrg  \n# -------------------------------------------  \n# encoding = utf-8  \nfrom random import Random\nfrom hashlib import md5\n\n\n# 获取由4位随机大小写字母、数字组成的salt值\ndef create_salt(length=4):\n    salt = ''\n    chars = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789'\n    len_chars = len(chars) - 1\n    random = Random()\n    for i in range(length):\n        # 每次从chars中随机取一位  \n        salt += chars[random.randint(0, len_chars)]\n    return salt\n\n\n# 获取原始密码+salt的md5值\ndef create_md5(pwd, salt):\n    md5_obj = md5()\n    md5_obj.update((pwd + salt).encode('utf-8'))\n    return md5_obj.hexdigest()\n\n\n# 原始密码\npwd = '20141124'\n# 随机生成4位salt  \nsalt = create_salt()\n# 加密后的密码  \nmd5 = create_md5(pwd, salt)\n\nprint('[pwd]\\n', pwd)\nprint('[salt]\\n', salt)\nprint('[md5]\\n', md5)\n```"},"children":[]},{"data":{"id":"bl8pwcwhp1c0","created":1525503612646,"text":"调试","note":"## try \n当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。\n```\ntry:\n    print('try...')\n    r = 10 / 0\n    print('result:', r)\nexcept ZeroDivisionError as e:\n    print('except:', e)\nfinally:\n    print('finally...')\nprint('END')\n```\n"},"children":[]},{"data":{"id":"bl8pwcwhjmwo","created":1525503612646,"text":"面向对象","note":"###  声明类\nclass后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。\n```\nclass Student(object):\n\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n    def print_score(self):\n        print('%s: %s' % (self.name, self.score))\nbart = Student('Bart Simpson', 59)\nbart.print_score()\n```\n#### type函数也可以创建类\n```\ndef fn(self, name='world'): # 先定义函数\n    print('Hello, %s.' % name)\nHello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class\n```\n### 私有属性\n__开头即可\n例如，__name属性为私有属性，类内部会偷偷改成 _Student__name，实现私有属性\n\nPython本身没有任何机制阻止你干坏事，一切全靠自觉\n\n###  “file-like object“ 鸭子类型\n对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。\n\n对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了\n\n\n###  类属性与实例属性\n```\nclass Student(object):\n    name = 'Student'\n```\n当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到\n#### 限制实例属性\n只能绑定某些属性\n```\nclass Student(object):\n    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称\n```\n#### 属性检查与控制 @property\n```\nclass Student(object):\n\n    @property\n    def score(self):\n        return self._score\n\n    @score.setter\n    def score(self, value):\n        if not isinstance(value, int):\n            raise ValueError('score must be an integer!')\n        if value < 0 or value > 100:\n            raise ValueError('score must between 0 ~ 100!')\n        self._score = value\n```\n调用方法\n```\n>>> s = Student()\n>>> s.score = 60 # OK，实际转化为s.set_score(60)\n>>> s.score # OK，实际转化为s.get_score()\n60\n>>> s.score = 9999\nTraceback (most recent call last):\n  ...\nValueError: score must between 0 ~ 100!\n```\n\n\n\n### 给类动态绑定方法\n```\ndef set_score(self, score):\n    self.score = score\nStudent.set_score = set_score\n```\n\n### 多重继承\n```\nclass Dog(Mammal, Runnable):\n    pass\n```\n\n### 定制类\n实现一些特殊函数，即可定制该类\n\n比如，实现__iter__，则该类可迭代，被循环\n```\nclass Fib(object):\n    def __init__(self):\n        self.a, self.b = 0, 1 # 初始化两个计数器a，b\n\n    def __iter__(self):\n        return self # 实例本身就是迭代对象，故返回自己\n\n    def __next__(self):\n        self.a, self.b = self.b, self.a + self.b # 计算下一个值\n        if self.a > 100000: # 退出循环的条件\n            raise StopIteration()\n        return self.a # 返回下一个值\nfor n in Fib():\n    print(n)\n\n```\n\n#### __getitem__\n可取下标，当做list使用\n#### __getattr__\n不存在某属性但是可以调用\n\n妙用，实现api,\n\n无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变\n```\nclass Chain(object):\n\n    def __init__(self, path=''):\n        self._path = path\n\n    def __getattr__(self, path):\n        return Chain('%s/%s' % (self._path, path))\n\n    def __str__(self):\n        return self._path\n\n    __repr__ = __str__\nprint(Chain().status.user.timeline.list)\n```\n#### __call__\n让实例像函数一样可以被调用\n```\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self):\n        print('My name is %s.' % self.name)\ns = Student('Michael')\ns() # self参数不要传入\n```\n\n### 枚举类\n两种写法\n```\nfrom enum import Enum\n\nMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))\nfor name, member in Month.__members__.items():\n    print(name, '=>', member, ',', member.value)\n```\n```\nfrom enum import Enum, unique\n\n@unique\nclass Weekday(Enum):\n    Sun = 0 # Sun的value被设定为0\n    Mon = 1\n    Tue = 2\n    Wed = 3\n    Thu = 4\n    Fri = 5\n    Sat = 6\nday1 = Weekday.Mon\nprint(day1,day1.value)\n```\n\n## 元类\n可以创建和修改类\n```\nclass ListMetaclass(type):\n    def __new__(cls, name, bases, attrs):\n        print(cls,name,bases,attrs)\n        attrs['add'] = lambda self, value: self.append(value)\n        return type.__new__(cls, name, bases, attrs)\nclass MyList(list, metaclass=ListMetaclass):\n    pass\nL = MyList()\nL.add(1)\nprint(L)\n```"},"children":[]},{"data":{"id":"bl8pwcwi3q0c","created":1525503612647,"text":"高级特性","note":"## 切片\nlist 、元组都可以操作，[:]复制整个\n```\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nL = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']\n\nprint('L[0:3] =', L[0:3])\nprint('L[:3] =', L[:3])\nprint('L[1:3] =', L[1:3])\nprint('L[-2:] =', L[-2:])\n\nR = list(range(100))\nprint('R[:10] =', R[:10])\nprint('R[-10:] =', R[-10:])\nprint('R[10:20] =', R[10:20])\nprint('R[:10:2] =', R[:10:2])\nprint('R[::5] =', R[::5])\n```\n\n## 列表生成式\n生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？\n```\n>>> [x * x for x in range(1, 11) if x % 2 == 0]\n[4, 16, 36, 64, 100]\n\n>>> [m + n for m in 'ABC' for n in 'XYZ']\n['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']\n\n```\n\n## 生成器\n\n间断执行，节省内存\n\n一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：\n\n案例，斐波那契数列\n```\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        a, b = b, a + b\n        n = n + 1\n    return 'done'\nf = fib(6)\nfor n in fib(6):\n    print(n)\n```\n\n\n## 迭代器\n\n可以直接作用于for循环的对象统称为可迭代对象：Iterable\n\n类是集合数据类型，如list、tuple、dict、set、str等；\n\n一类是generator，包括生成器和带yield的generator function。\n\n```\nfrom collections import Iterable\nprint(isinstance([], Iterable)) \n```"},"children":[]}]},"template":"default","theme":"fresh-blue","version":"1.4.33"}