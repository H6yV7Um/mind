{"root":{"data":{"id":"bl8pjam7rogk","created":1525502588937,"text":"typeScript","note":"."},"children":[{"data":{"id":"bl8pjm38s4oo","created":1525502613911,"text":"基础语法","note":"## 数据类型\n数字，字符串，结构体，布尔值、枚举类型、联合类型\n```JavaScript\nlet isDone: boolean = false;\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\nlet binaryLiteral: number = 0b1010;\nlet octalLiteral: number = 0o744;\nlet name: string = \"bob\";\n```\n\n## 函数\n1. 可选参数 参数后面带问号\n## 杂项\n1. 模板字符串（支持换行、插值）\n\n```JavaScript\nlet sentence: string = `Hello, my name is ${ name }.\nI'll be ${ age + 1 } years old next month.`;\n\n```\n## 类型\n1. 声明类型\n```JavaScript\n//数组的两种声明方式\nlet list: number[] = [1, 2, 3];\nlet list: Array<number> = [1, 2, 3];\n```\n2. 元组 Tuple 类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。\n```JavaScript\n// Declare a tuple type\nlet x: [string, number];\n// Initialize it\nx = ['hello', 10]; // OK\n// Initialize it incorrectly\nx = [10, 'hello']; // Error\n```\n"},"children":[]},{"data":{"id":"bl8pkiaqf9c0","created":1525502684021,"text":"环境搭建","note":"## 安装\n\n```\nnpm install -g typescript\n```\n## 编译\n\n```\ntsc greeter.ts\n```\n\n\n### 实时调试\n\n首先，目录结构须有index.html、src、build分别放首页、开发与打包目录\n\n1. package.json,没有什么特殊之处\n\n主要是\"start\": \"webpack-dev-server --open\"\n另外需安装依赖 webpack、webpack-dev-server\n\n```\n{\n  \"name\": \"mm\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"start\": \"webpack-dev-server --open\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n\n```\n2. webpak.config.js\n\n```\nmodule.exports = {\n    entry:  __dirname + \"/src/index.ts\",//已多次提及的唯一入口文件\n    devtool: 'source-map',\n    devServer: {\n        contentBase: \"./\",//本地服务器所加载的页面所在的目录\n        historyApiFallback: true,//不跳转\n        inline: true,//实时刷新\n        port:'2335'\n    },\n    module: {\n\n        rules: [\n            { test: /\\.ts?$/, loader: \"ts-loader\" }\n        ]\n    },\n    output: {\n    path: __dirname + \"/build/\",//打包后的文件存放的地方\n        filename: \"bundle.js\"//打包后输出文件的文件名\n    }\n}\n\n\n```\n3. 跟目录下存放tsconfig.json\n\n```\n{\n    \"compileOnSave\": false,\n    \"compilerOptions\": {\n      \"outDir\": \"./build\",\n      \"sourceMap\": true,\n      \"declaration\": false,\n      \"moduleResolution\": \"node\",\n      \"emitDecoratorMetadata\": true,\n      \"experimentalDecorators\": true,\n      \"target\": \"es5\",\n      \"typeRoots\": [\n        \"node_modules/@types\"\n      ],\n      \"lib\": [\n        \"es2017\",\n        \"dom\"\n      ]\n    }\n}\n  \n```"},"children":[]},{"data":{"id":"bl8pkqgg1i8g","created":1525502701781,"text":"面向对象","note":"## 继承例子\n\n这里， Dog是一个 派生类，它派生自 Animal 基类，通过 extends关键字。 派生类通常被称作 子类，基类通常被称作 超类。\n```\nclass Animal {\n    name: string;\n    constructor(theName: string) { this.name = theName; }\n    move(distanceInMeters: number = 0) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Snake extends Animal {\n    constructor(name: string) { super(name); }\n    move(distanceInMeters = 5) {\n        console.log(\"Slithering...\");\n        super.move(distanceInMeters);\n    }\n}\n\nclass Horse extends Animal {\n    constructor(name: string) { super(name); }\n    move(distanceInMeters = 45) {\n        console.log(\"Galloping...\");\n        super.move(distanceInMeters);\n    }\n}\n\nlet sam = new Snake(\"Sammy the Python\");\nlet tom: Animal = new Horse(\"Tommy the Palomino\");\n\nsam.move();\ntom.move(34);\n```\n\n## 私有属性\n\n```\nclass Animal {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nnew Animal(\"Cat\").name; // 错误: 'name' 是私有的.\n```"},"children":[]},{"data":{"id":"bl8pjxou0q0o","created":1525502639161,"text":"接口","note":"### 例子\n\n预先定义某个类型，比如下面，定义一个结构必然有键名为label值为string的对象\n\n```\ninterface LabelledValue {\n  label: string;\n}\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label);\n}\n\nlet myObj = {size: 10, label: \"Size 10 Object\"};\nprintLabel(myObj);\n```\n\n### 类型断言\n可以绕过类型检查\n```\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\na = ro as number[];\n```\n\n### 可选属性\n\n可能有可能没有，有的话类型也是确定的\n```\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n```\n\n## 只读属性\n\n特点：\n1. 刚创建的时候可以修改\n2. 不可修改\n3. 不可以赋值给其他变量\n\n```\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n```\n## 额外的属性\n字符串索引签名([propName: string]),这里表示\nSquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。\n```\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n    [propName: string]: any;\n}\n```\n\n## 函数类型的接口\n参数顺序要一致，但名字不必一致\n```\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\nlet mySearch: SearchFunc;\nmySearch = function(src: string, sub: string): boolean {\n  let result = src.search(sub);\n  return result > -1;\n}\n```\n\n### 可索引类型\n\n暂时理解为，扩展接口内定义字段的个数\n\n 这个索引签名表示了当用 string去索引StringArray时会得到任意类型的返回值。\n```\ninterface StringArray {\n  [index: string]: any;\n}\n\nlet myArray: StringArray;\nmyArray = [\"Bob\", \"Fred\"];\n\nlet myStr: string = myArray[0];\n```\n设置为只读模式防止索引类型被修改\n```\ninterface ReadonlyStringArray {\n    readonly [index: number]: string;\n}\nlet myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];\nmyArray[2] = \"Mallory\"; // error!\n```\n\n\n## 类类型\n\n强制一个类去符合某种契约\n\nimplements\n\nconstructor存在于类的静态部分，所以不在检查的范围内。\n\n```\ninterface ClockInterface {\n    currentTime: Date;\n    setTime(d: Date);\n}\n\nclass Clock implements ClockInterface {\n    currentTime: Date;\n    setTime(d: Date) {\n        this.currentTime = d;\n    }\n    constructor(h: number, m: number) { }\n}\n```\n\n## 接口互相继承\n\n```\ninterface Shape {\n    color: string;\n}\n\ninterface PenStroke {\n    penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n    sideLength: number;\n}\n\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n```\n\n## 接口继承类\n\n接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。\n\n```\nclass Control {\n    private state: any;\n}\n\ninterface SelectableControl extends Control {\n    select(): void;\n}\n\nclass Button extends Control implements SelectableControl {\n    select() { }\n}\n\nclass TextBox extends Control {\n\n}\n\n// 错误：“Image”类型缺少“state”属性。\nclass Image implements SelectableControl {\n    select() { }\n}\n```\n"},"children":[]}]},"template":"default","theme":"fresh-blue","version":"1.4.33"}