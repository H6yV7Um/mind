{"root":{"data":{"id":"bl8pnebz7uw4","created":1525502910482,"text":"js基础"},"children":[{"data":{"id":"bl8pnlhsi00g","created":1525502926071,"text":"函数","note":"## 参数\narguments，函数作用域内变量，\n```\nvar arguments = 23;\nfunction b(a){\n console.log(arguments)\n}\nb(2)\n//打印出该函数的arguments\n```\n\n## call appy\n非继承而来的方法\n\n用来代替另一个对象调用一个方法\n```\nfunction add(c,d){\n    return this.a + this.b + c + d;\n}\n\nvar s = {a:1, b:2};\nconsole.log(add.call(s,3,4)); // 1+2+3+4 = 10\nconsole.log(add.apply(s,[5,6])); // 1+2+5+6 = 14 \n```"},"children":[]},{"data":{"id":"bl8ponm6i6wc","created":1525503009054,"text":"BOM","note":"\n\n## 请求\n说一说常见的请求头和相应头都有什么呢？\n1)请求(客户端->服务端[request]) \n    GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号) \n    Accept: */*(客户端能接收的资源类型) \n    Accept-Language: en-us(客户端接收的语言类型) \n    Connection: Keep-Alive(维护客户端和服务端的连接关系) \n    Host: localhost:8080(连接的目标主机和端口号) \n    Referer: http://localhost/links.asp(告诉服务器我来自于哪里) \n    User-Agent: Mozilla/4.0(客户端版本号的名字) \n    Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型) \n    If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)  \n    Cookie(客户端暂存服务端的信息) \n    Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间)\n\n2)响应(服务端->客户端[response])\n    HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)\n    Location: http://www.baidu.com(服务端需要客户端访问的页面路径) \n    Server:apache tomcat(服务端的Web服务端名)\n    Content-Encoding: gzip(服务端能够发送压缩编码类型) \n    Content-Length: 80(服务端发送的压缩数据的长度) \n    Content-Language: zh-cn(服务端发送的语言类型) \n    Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)\n    Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)\n    Refresh: 1;url=http://www.it315.org(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)\n    Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)\n    Transfer-Encoding: chunked(分块传递数据到客户端）  \n    Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)\n    Expires: -1//3种(服务端禁止客户端缓存页面数据)\n    Cache-Control: no-cache(服务端禁止客户端缓存页面数据)  \n    Pragma: no-cache(服务端禁止客户端缓存页面数据)   \n    Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  \n    Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)\n在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息，解决跨域的一种方法。\n\n\n"},"children":[]},{"data":{"id":"bl8ppi38duok","created":1525503075388,"text":"内置对象","note":"## Boolean\n```\nvar x = new Boolean(false);\nif (x) {\n  alert('hi');\n}\nvar y = Boolean(0);\nif (y) {\n  alert('hello'); \n}\n```\nx为new出来的对象，直接判断为true，y为对象值，判断为false\n\n##  Math\n1. 计算x的y次方\n```\nMath.pow(x, y)\n```\n\n## Array\n1. 数组删除元素的语法\n```\n//arrayObject.splice(index,howmany,item1,.....,itemX)------item1, ..., itemX\t可选。向数组添加的新项目。\n//删除arr数组中的第i个元素 ----arr.splice(i-1,1)\n\n```\n\n##  String 对象\n+ charAt()\ncharAt() 方法可返回指定位置的字符。\n```\nvar str=\"Hello world!\"\nstr.charAt(1);\n```\n\n\n\n\n## 图灵测试失败，强制结束并重启。\n## ps 快捷键\n+ 复制图层：右键图层 ctrl+J\n+ 去色处理：Ctrl+U 饱和度最低 变为黑白色\n+ 锐化：滤镜——锐化——USM锐化\n+ 反相：ctrl+I\n+ 向下合并:ctrl+E \n+ 曲线工具：CTRL+M\n+ 常用的最后处理：复制图层--正片叠底--合并图层\n+ 前景色填充：拾色器选择颜色---alt+delete---\n+ 混合选项：右键图层--打开混合选项---按住alt键，滑动下一图层\n+ 添加蒙版：选择图层---下方类似于相机的按钮点击即可\n+ 添加杂色：滤镜--杂色---添加杂色\n+ 实际操作\n1. 做出线稿：去色---反相---线性减淡--滤镜其他最小值---（调整数值到线条出现）\n2. 素描处理：新建图层（背景填充为黑色，混合属性改为色相）--向下合并再复制----将上一步最后的复本反相---复本混合选项改为颜色减淡---滤镜其他最小值1像素---混合选项调整“下一图层”，合并----添加蒙版---添加杂色（150%，平均分布）---动感模糊----至此完成（接下来将背景素描化）----新建图层，填充f0f0f0，调节该图层填充度即可\n## 通道抠图的原理\n1. 更改色系\n2. 选择合适对比的通读（被抠者与背景对比强烈）\n3. 在通道中变成黑白\n4. 快速选择工具\n5. 在图层中粘贴\n## 更改色系\n1. 创建可选颜色调整图层\n## 如何融入背景 \n1. 建立选区，羽化\n2. 反选，delete\n\n  \n"},"children":[]},{"data":{"id":"bl8ppz2h3d44","created":1525503112348,"text":"原型链","note":"1. 对象的理解\n    1. 分为函数对象、普通对象（凡是通过new Function()创建的都是函数对象） \n    2. 所有对象都有__proto__属性，函数对象额外多一个prototype属性，该属性是一个对象，叫做原型对象\n    3. 有哪些函数对象：Function、Object、Array、Date、String、自定义函数\n    4. 关于原型对象\n    ```JavaScript\n    function Person () {\n\n    } \n    ```\n    在以上代码中，创建了函数对象Person，Person.prototype叫做person的原型对象\n    Person.prototype.constructor指向函数对象person\n2. 继承的理解\n```JavaScript\nfunction Person () {        \n}\n// 可以使用Person.prototype 直接访问到原型对象\n//给Person函数的原型对象中添加一个属性 name并且值是 \"张三\"\nPerson.prototype.name = \"张三\";\nPerson.prototype.age = 20;\nvar p1 = new Person();\nalert(p1.name);  // 张三\nvar p2 = new Person();\nalert(p2.name);  // 张三  都是从原型中找到的，所以一样。\nalert(p1.name === p2.name);  // true\n// 由于不能修改原型中的值，则这种方法就直接在p1中添加了一个新的属性name，然后在p1中无法再访问到\np1.name = \"李四\";\nalert(\"p1：\" + p1.name);\n// 由于p2中没有name属性，则对p2来说仍然是访问的原型中的属性。    \nalert(\"p2:\" + p2.name);  // 张三 \n```\n\n其中p1.__proto__ === Person.prototype === p2.__proto__ ，即所有对象的__proto__指向其构造函数的原型对象\n3. 如何判断一个属性是否在原型中\nhasOwnProperty与in操作结合使用\n\n"},"children":[]},{"data":{"id":"bl8pqebx7ugw","created":1525503145571,"text":"媒体查询","note":"## 示例代码\n\n```\n    let mql = window.matchMedia(\"(max-width: 1149px)\");\n    if(mql.matches){\n        console.log(1)\n        this.ifShow = false;\n        this.ifMObile = true;\n    }else{\n        console.log(2)\n        this.ifShow = true;\n        this.ifMObile = false;\n    }\n    mql.addListener((mql)=>{\n        if(mql.matches){\n        console.log(1)\n        this.ifShow = false;\n        this.ifMObile = true;\n        }else{\n            console.log(2)\n            this.ifShow = true;\n            this.ifMObile = false;\n        }\n    });\n```"},"children":[]},{"data":{"id":"bl8pqyu53tc8","created":1525503190208,"text":"浮点数计算","note":"解决办法 （加减乘除）\n\n```\n(function () {\n    var calc = {\n        /*\n        函数，加法函数，用来得到精确的加法结果  \n        说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。\n        参数：arg1：第一个加数；arg2第二个加数；d要保留的小数位数（可以不传此参数，如果不传则不处理小数位数）\n        调用：Calc.Add(arg1,arg2,d)  \n        返回值：两数相加的结果\n        */\n        Add: function (arg1, arg2) {\n            arg1 = arg1.toString(), arg2 = arg2.toString();\n            var arg1Arr = arg1.split(\".\"), arg2Arr = arg2.split(\".\"), d1 = arg1Arr.length == 2 ? arg1Arr[1] : \"\", d2 = arg2Arr.length == 2 ? arg2Arr[1] : \"\";\n            var maxLen = Math.max(d1.length, d2.length);\n            var m = Math.pow(10, maxLen);\n            var result = Number(((arg1 * m + arg2 * m) / m).toFixed(maxLen));\n            var d = arguments[2];\n            return typeof d === \"number\" ? Number((result).toFixed(d)) : result;\n        },\n        /*\n        函数：减法函数，用来得到精确的减法结果  \n        说明：函数返回较为精确的减法结果。 \n        参数：arg1：第一个加数；arg2第二个加数；d要保留的小数位数（可以不传此参数，如果不传则不处理小数位数\n        调用：Calc.Sub(arg1,arg2)  \n        返回值：两数相减的结果\n        */\n        Sub: function (arg1, arg2) {\n            return Calc.Add(arg1, -Number(arg2), arguments[2]);\n        },\n        /*\n        函数：乘法函数，用来得到精确的乘法结果  \n        说明：函数返回较为精确的乘法结果。 \n        参数：arg1：第一个乘数；arg2第二个乘数；d要保留的小数位数（可以不传此参数，如果不传则不处理小数位数)\n        调用：Calc.Mul(arg1,arg2)  \n        返回值：两数相乘的结果\n        */\n        Mul: function (arg1, arg2) {\n            var r1 = arg1.toString(), r2 = arg2.toString(), m, resultVal, d = arguments[2];\n            m = (r1.split(\".\")[1] ? r1.split(\".\")[1].length : 0) + (r2.split(\".\")[1] ? r2.split(\".\")[1].length : 0);\n            resultVal = Number(r1.replace(\".\", \"\")) * Number(r2.replace(\".\", \"\")) / Math.pow(10, m);\n            return typeof d !== \"number\" ? Number(resultVal) : Number(resultVal.toFixed(parseInt(d)));\n        },\n        /*\n        函数：除法函数，用来得到精确的除法结果  \n        说明：函数返回较为精确的除法结果。 \n        参数：arg1：除数；arg2被除数；d要保留的小数位数（可以不传此参数，如果不传则不处理小数位数)\n        调用：Calc.Div(arg1,arg2)  \n        返回值：arg1除于arg2的结果\n        */\n        Div: function (arg1, arg2) {\n            var r1 = arg1.toString(), r2 = arg2.toString(), m, resultVal, d = arguments[2];\n            m = (r2.split(\".\")[1] ? r2.split(\".\")[1].length : 0) - (r1.split(\".\")[1] ? r1.split(\".\")[1].length : 0);\n            resultVal = Number(r1.replace(\".\", \"\")) / Number(r2.replace(\".\", \"\")) * Math.pow(10, m);\n            return typeof d !== \"number\" ? Number(resultVal) : Number(resultVal.toFixed(parseInt(d)));\n        }\n    };\n    window.Calc = calc;\n}());\n```"},"children":[]},{"data":{"id":"bl8prgohcpc8","created":1525503229048,"text":"类型转换","note":"## +\n+为正值，将字符串等转换为数值\n```\n+new Array() //NaN\n```"},"children":[]},{"data":{"id":"bl8prxt973sw","created":1525503266342,"text":"语法","note":"## map\n```\n[11,22,33].map(function(currentValue,index,arr){console.log(currentValue,index,arr)},2)\n```\n\n## 类型判断 typeof\n```\ntypeof new Date()\n//'object'\n```\n## 判断是否数组、日期对象、对象、函数对象\n```\nObject.prototype.toString.call([])\n//\"[object Array]\"\nObject.prototype.toString.call({})\n//\"[object Object]\"\nObject.prototype.toString.call(new Date())\n//\"[object Date]\"\nObject.prototype.toString.call(new Function())\n\"[object Function]\"\n```\n\n## json或者数组键名首字母小写\n```\nfunction lowerJSONKey(jsonObj){//json或者数组键名首字母小写\n    var objType = Object.prototype.toString.call(jsonObj);\n    if(objType==\"[object Object]\"){\n        for (var key in jsonObj){\n            if(key[0].toLowerCase()===key[0]){\n                console.log('首字母小写跳过');\n                var objType2 = Object.prototype.toString.call(jsonObj[key]);\n                if(objType2 == \"[object Object]\"|| objType2 == \"[object Array]\"){\n                    jsonObj[key] = lowerJSONKey(jsonObj[key]);\n                }\n                continue;\n            }\n            var name = key[0].toLowerCase()+key.substring(1);\n            jsonObj[name] = jsonObj[key];\n            delete(jsonObj[key]);\n            var objType2 = Object.prototype.toString.call(jsonObj[name]);\n            if(objType2 == \"[object Object]\"|| objType2 == \"[object Array]\"){\n                jsonObj[name] = lowerJSONKey(jsonObj[name]);\n            }\n        }\n        return jsonObj;\n    }else if(objType==\"[object Array]\"){\n        for (var i = 0; i < jsonObj.length; i++) {\n            jsonObj[i] = lowerJSONKey(jsonObj[i]);\n        }\n        return jsonObj;\n    }else {\n        return jsonObj;\n    }\n}\n```\n## 数据类型\n+ ES5 中的基本数据类型有 5 种：Undefined、Null、Boolean、Number、String.而 Object 是属于复杂数据类型\n+ ES6 后新增了一类数据类型 ：Symbol\n\n\n"},"children":[]},{"data":{"id":"bl8ps4ecazcc","created":1525503280678,"text":"闭包","note":"## 本质\n+ 闭包就是能够读取其他函数内部变量的函数。\n+ 可以把闭包简单理解成\"定义在一个函数内部的函数\"。\n\n## 用途\n+ 可以读取函数内部的变量，\n+ 让这些变量的值始终保持在内存中。\n\n## 例子\n+ 代码，求和函数\n    ```\n    function lazy_sum(arr) {\n        var sum = function () {\n            return arr.reduce(function (x, y) {\n                return x + y;\n            });\n        }\n        return sum;\n    }\n    ```\n+ 在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。\n\n## 匿名函数立即执行\n+ 无法正常打印i，都是20\n```\nfor (var i = 0; i < 20; i++) {\n    setTimeout(function(){\n        console.log(i)\n    },100)\n}\n```\n+ 解决办法,匿名函数立即执行\n```JavaScript\nfor (var i = 0; i < 20; i++) {\n    (function(x){\n        setTimeout(function(){\n            console.log(x)\n        },1000)\n    })(i)\n}\n```\n\n## 好处\n1. 封装一个私有变量\n```\n//一个计数器代码\n'use strict';\nfunction create_counter() {\n    var x =  0;\n    return {\n        inc: function () {\n            x += 1;\n            return x;\n        }\n    }\n}\nvar c1 = create_counter();\nc1.inc(); // 1\nc1.inc(); // 2\nc1.inc(); // 3\n```\n外部无法访问到内部的x变量\n2. 多参数的函数变成单参数的函数\n    + 例子,计算平方与三次方的函数\n    ```\n    function make_pow(n) {\n        return function (x) {\n            return Math.pow(x, n);\n        }\n    }\n\n    // 创建两个新函数:\n    var pow2 = make_pow(2);\n    var pow3 = make_pow(3);\n\n    pow2(5); // 25\n    pow3(7); // 343\n    ``` \n\n## todo \n\n\n\n\n\n"},"children":[]},{"data":{"id":"bl8prnxmewgs","created":1525503244838,"text":"计算优先级","note":"+ 加号优先于三目运算符\n```\nconsole.log('Value is ' + (val != '0') ? 'define' : 'undefine');\n//先计算'Value is ' + (val != '0')\n```"},"children":[]},{"data":{"id":"bl8pr919zfkg","created":1525503212408,"text":"奇怪的考题","note":"## 判断一些奇怪的相等\n```\n//undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true。 \nundefined == null //true;\nundefined === null //false\n```\n"},"children":[]},{"data":{"id":"bl8pql186ego","created":1525503160162,"text":"字符串处理","note":"## encodeURI() 函数\n可把字符串作为 URI 进行编码。\n"},"children":[]},{"data":{"id":"bl8pq7k2dhk4","created":1525503130826,"text":"作用域","note":"## Javascript特殊的变量作用域。\n+ 变量的作用域无非就是两种：全局变量和局部变量。\n\n+ Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量\n\n+ 函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！\n```\nfunction f1(){\n　　　　n=999;\n　　}\n　　f1();\n　　alert(n); // 999\n```\n\n## 错题例子\n+ javascript只有函数域，没有块作用域的概念，所以在同一个作用域中同一个变量声明多次还是第一次声明那个！\n```\nvar msg='hello';\nfor (var i=0; i<10; i++)\n{\n    var msg='hello'+i*2+i;\n}\nalert(msg);//hello189\n\n```\n"},"children":[]},{"data":{"id":"bl8ppqcx37s4","created":1525503093388,"text":"冒泡","note":"## 冒泡与捕获\n\n+ 起源\n    + 假设你在一个元素中又嵌套了另一个元素（element1包着element2），点击事件怎么算\n    + 方案\n        + 冒泡，从内到外\n        + 捕获，从外到内\n+ 我们怎么写\n```\n//true 捕获阶段\nelement1.addEventListener('click',dosomenthing,true);\nelement2.addEventListener('click',dosomenthing,false);\n```\n## 取消事件的默认动作。\n event.preventDefault()"},"children":[]},{"data":{"id":"bl8pp7iqw4gg","created":1525503052382,"text":"ES6","note":"## let 有变量提升？\n如下，报错，not defined,因为函数内test变量提升了，但是不能再声明前使用\n```JavaScript\n'use strict';\nvar test = 1;\nfunction func(){\n    //打印test的值\n    console.log(test);\n    let test = 2;\n};\nfunc();\n```\n\n\n## 箭头函数\n+\n```\n//例子1\nvar f = () => 5;\n// 等同于\nvar f = function () { return 5 };\n//例子2\nconst full = ({ first, last }) => first + ' ' + last;\n```\n1. 如果无参数或者参数多-----前面用小括号\n2. 如果代码块>一句---中括号\n3. 箭头函数中不存在 this、 arguments、super、new.target\n4. this会找到定义时所在的this\n\n## 数组操作\n+ map\n```\n[1.2.3].map((x)=>{\n    return x+1;\n})                      //[2,3,4]\n```\n+ find\n```\n[1,2,3,4].find((value)=>{\n    return value>2;\n})              //3\n```\n+ filter\n```\n[1.2.3].filter((x)=>{\n    return x%2===0;\n})                      //[2]\n```\n\n##  reduce\n数组求和\n```\nvar arr = [1, 3, 5, 7, 9];\narr.reduce(function (x, y) {\n    return x + y;\n});\n``` \n\n## generator\n1. 一种新的数据类型\n2. 看上去像个函数，但多个* ,可以多次返回\n3. 会记住执行状态(变量值不变，执行到的语句不变)\n4. 执行后返回一个generator，.next()才会真正执行\n4. 如下的一个斐波那契数列函数\n```\nfunction* fib(max) {\n    console.log(1);\n    var\n        t,\n        a = 0,\n        b = 1,\n        n = 1;\n    console.log(2);\n    while (n < max) {\n    console.log(3);\n        yield n;\n    console.log(4);\n        t = a + b;\n        a = b;\n        b = t;\n        n ++;\n    console.log(5);\n    }\n    console.log(6);\n    return a;\n}\nvar bb = fib(5);\nbb.next();\nbb.next();\nbb.next();\n```\n\n## promise\n+ synchronous 同步\n+ 特点\n    1. 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。\n    2. 就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。"},"children":[]},{"data":{"id":"bl8pntb6wnsc","created":1525502943086,"text":"异步","note":"## promise\n\n### 链式操作\n```\nrunAsync1()\n.then(function(data){\n    console.log(data);\n    return runAsync2();\n})\n.then(function(data){\n    console.log(data);\n    return runAsync3();\n})\n.then(function(data){\n    console.log(data);\n});\n```\n\n### all \n全部完成为准\n```\nPromise\n.all([runAsync1(), runAsync2(), runAsync3()])\n.then(function(results){\n    console.log(results);\n});\n```\n\n### race\n谁跑的快，以谁为准执行回调\n```\nPromise\n.race([runAsync1(), runAsync2(), runAsync3()])\n.then(function(results){\n    console.log(results);\n});\n```\n"},"children":[]}]},"template":"default","theme":"fresh-blue","version":"1.4.33"}